import ot

import numpy as np
import jax.numpy as jnp

from sklearn.neighbors import KNeighborsClassifier

from .utils_bw import bures_wasserstein_batch


def get_labels(X_data_tgt, y_tgt, xk):
    """
        Relabel the data xb to correspond to X_data_tgt by OT matching

        X_data_tgt: ndarray of shape (nc, m, d)
        y_tgt: ndarray of shape (nc, m)
        xk: ndarray of shape (nc, n, d)

        returns xk_labels, array of shape (nc, n)
    """
    n_classes, n, d = xk.shape
    n_classes, m, d = X_data_tgt.shape

    y_tgt = y_tgt.astype(int)

    C = np.zeros((n_classes, n_classes))
    for i in range(n_classes):
        for j in range(n_classes):
            M = ot.dist(X_data_tgt[y_tgt[i][0]], np.array(xk[j]))
            a = np.ones(m) / m
            b = np.ones(n) / n
            C[y_tgt[i][0], j] = ot.emd2(a, b, M)

    a = np.ones(n_classes) / n_classes
    b = np.ones(n_classes) / n_classes
    P = ot.emd(a, b, C)

    xk_labels = np.argmax(P, axis=0)

    xk_labels_out = np.zeros((n_classes, n))
    for k in range(n_classes):
        xk_labels_out[k] = xk_labels[k]

    return xk_labels_out.astype(int)


def get_labels_1nn(X_data_tgt, y_tgt, xk):
    """
        Relabel the data xb to correspond to X_data_tgt by 1-NN

        X_data_tgt: ndarray of shape (nc, m, d)
        y_tgt: ndarray of shape (nc, m)
        xk: ndarray of shape (nc, n, d)

        returns xk_labels, array of shape (nc, n)
    """
    n_classes, n, d = xk.shape

    # Get class of each cluster of xk
    knn = KNeighborsClassifier(1)
    knn.fit(X_data_tgt.reshape(-1, d), y_tgt.reshape(-1,).astype(int))

    xk_labels = []
    for k in range(n_classes):
        # Majority vote
        labels = knn.predict(xk[k])
        unique_labels, counts = np.unique(labels, return_counts=True)
        xk_labels.append([unique_labels[np.argmax(counts)]] * len(labels))

    xk_labels = np.array(xk_labels)
    return xk_labels


def get_labels_mmd_product(mu_tgt, cov_tgt, y_tgt, xk):
    """
        Solve LP to get the labels, cf [1]

        Parameters
        ----------
        mu_tgt: ndarray of shape (n_class, reduced_dim)
        cov_tgt: ndarray of shape (n_class, reduced_dim, reduced_dim)
        y_tgt: ndarray of shape (n_class, m_data_by_class)
        xk: tuple of (x, mu, cov)

        [1] Hua, X., Nguyen, T., Le, T., Blanchet, J., & Nguyen, V. A. (2023).
        Dynamic flows on curved space generated by labeled data.
        arXiv preprint arXiv:2302.00061.
    """
    x, mu, cov = xk
    x = np.clip(x, 0, 1)

    n = len(y_tgt.reshape(-1,))
    classes = np.unique(y_tgt)
    M = bures_wasserstein_batch(mu_tgt, mu, cov_tgt, cov)
    a = jnp.array([np.sum(y_tgt == k)/n for k in classes])
    b = jnp.ones(len(x)) / len(x)
    P = ot.emd(a, b, M)

    xk_labels = jnp.argmax(P, axis=0)
    return xk_labels
